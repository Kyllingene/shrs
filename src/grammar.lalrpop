use std::str::FromStr;
use crate::ast;

grammar;

pub Prgoram: ast::Command = {
    Linebreak <cs:CompleteCommands> Linebreak => cs,
    Linebreak => ast::Command::None,
}

pub CompleteCommands: ast::Command = {
    <cs:CompleteCommands> NewlineList <c:CompleteCommand> => ast::Command::SeqList(Box::new(cs), Some(Box::new(c))), // double check seqlist is correct here
    <c:CompleteCommand> => c,
}

pub CompleteCommand: ast::Command = {
    <l:List> <s:SeperatorOp> => {
        match s {
	      ast::SeperatorOp::Amp => ast::Command::AsyncList(Box::new(l), None),
	      ast::SeperatorOp::Semi => ast::Command::SeqList(Box::new(l), None),
	} 
    },
    <l:List> => l,
}

pub List: ast::Command = {
    <l:List> <s:SeperatorOp> <a:AndOr> => {
        match s {
	      ast::SeperatorOp::Amp => ast::Command::AsyncList(Box::new(l), Some(Box::new(a))),
	      ast::SeperatorOp::Semi => ast::Command::SeqList(Box::new(l), Some(Box::new(a))),
	} 
    },
    <a:AndOr> => a,
}

pub AndOr: ast::Command = {
    <a:AndOr> AND_IF Linebreak <p:Pipeline> => ast::Command::And(Box::new(a), Box::new(p)),
    <a:AndOr> OR_IF Linebreak <p:Pipeline> => ast::Command::Or(Box::new(a), Box::new(p)),
    <p:Pipeline> => p,
}

pub Pipeline: ast::Command = {
    "!" <ps:PipeSequence> => ast::Command::Not(Box::new(ps)),
    <ps:PipeSequence> => ps,
}

pub PipeSequence: ast::Command = {
    <ps:PipeSequence> "|" Linebreak <c:Command> => ast::Command::Pipeline(Box::new(ps), Box::new(c)),
    <c:Command> => c,
}

pub Command: ast::Command = {
    <s:Simple> => s,
}

pub Simple: ast::Command = {
    <assigns: Assign*> <prefix: Redirect*> <words: CommandWord+> <suffix: Redirect*> => {
    	let redirects = prefix.into_iter().chain(suffix.into_iter()).collect();
	ast::Command::Simple { assigns, redirects, args: words }
    }
}

pub Redirect: ast::Redirect = {
    <n: IONumber?> "<"  <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::Read },
    <n: IONumber?> ">"  <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::Write },
    <n: IONumber?> "<<" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadAppend },
    <n: IONumber?> ">>" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::WriteAppend },
    <n: IONumber?> "<&" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadDup },
    <n: IONumber?> ">&" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::WriteDup },
    <n: IONumber?> "<>" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadWrite },
}

pub IONumber: ast::IONumber = r"[0-9]+" => ast::IONumber(usize::from_str(<>).unwrap());
pub CommandWord: ast::Word = r"[\-a-zA-Z][\-a-zA-Z0-9]*" => ast::Word(<>.into());
pub Filename: ast::Filename = r"[\-a-zA-Z][\-a-zA-Z0-9]*" => ast::Filename(<>.into());

pub Assign: ast::Assign = <var:CommandWord> "=" <val:CommandWord> => ast::Assign { var, val };

pub AND_IF: () = "&&" => ();
pub OR_IF: () = "||" => ();

pub Linebreak: () = NewlineList? => ();
pub NewlineList: () = "\n"+ => ();
pub Seperator: Option<ast::SeperatorOp> = {
    <s:SeperatorOp> Linebreak => Some(s),
    NewlineList => None,
}
pub SeperatorOp: ast::SeperatorOp = {
    "&" => ast::SeperatorOp::Amp,
    ";" => ast::SeperatorOp::Semi,
}