use std::str::FromStr;
use crate::ast;

grammar;

pub Program: ast::Command = {
    Linebreak <cs:CompleteCommands> Linebreak => cs,
    Linebreak => ast::Command::None,
}

pub CompleteCommands: ast::Command = {
    <cs:CompleteCommands> NewlineList <c:CompleteCommand> => ast::Command::SeqList(Box::new(cs), Some(Box::new(c))), // double check seqlist is correct here
    <c:CompleteCommand> => c,
}

pub CompleteCommand: ast::Command = {
    <l:List> <s:SeperatorOp> => {
        match s {
	      ast::SeperatorOp::Amp => ast::Command::AsyncList(Box::new(l), None),
	      ast::SeperatorOp::Semi => ast::Command::SeqList(Box::new(l), None),
	} 
    },
    <l:List> => l,
}

pub List: ast::Command = {
    <l:List> <s:SeperatorOp> <a:AndOr> => {
        match s {
	      ast::SeperatorOp::Amp => ast::Command::AsyncList(Box::new(l), Some(Box::new(a))),
	      ast::SeperatorOp::Semi => ast::Command::SeqList(Box::new(l), Some(Box::new(a))),
	} 
    },
    <a:AndOr> => a,
}

pub AndOr: ast::Command = {
    <a:AndOr> AND_IF Linebreak <p:Pipeline> => ast::Command::And(Box::new(a), Box::new(p)),
    <a:AndOr> OR_IF Linebreak <p:Pipeline> => ast::Command::Or(Box::new(a), Box::new(p)),
    <p:Pipeline> => p,
}

pub Pipeline: ast::Command = {
    "!" <ps:PipeSequence> => ast::Command::Not(Box::new(ps)),
    <ps:PipeSequence> => ps,
}

pub PipeSequence: ast::Command = {
    <ps:PipeSequence> "|" Linebreak <c:Command> => ast::Command::Pipeline(Box::new(ps), Box::new(c)),
    <c:Command> => c,
}

pub Command: ast::Command = {
    <s:SimpleCommand> => s,
    <c:CompoundCommand> => c,
}

pub SimpleCommand: ast::Command = {
    <assigns: Assign*> <prefix: Redirect*> <words: CommandWord+> <suffix: Redirect*> => {
    	let redirects = prefix.into_iter().chain(suffix.into_iter()).collect();
	ast::Command::Simple { assigns, redirects, args: words }
    }
}

pub CompoundCommand: ast::Command = {
    <s:Subshell> => ast::Command::Subshell(Box::new(s)),
    <i:IfClause> => i,
    <w:WhileClause> => w,
    <u:UntilClause> => u,
}

// SUBSHELL

pub Subshell: ast::Command = {
    "(" <c:CompoundList> ")" => c,
}

pub CompoundList: ast::Command = {
    Linebreak <t:Term> => t,
    Linebreak <t:Term> <s:Seperator> => {
	match s {
	      None => t,
	      Some(ast::SeperatorOp::Amp) => ast::Command::AsyncList(Box::new(t), None),
	      Some(ast::SeperatorOp::Semi) => ast::Command::SeqList(Box::new(t), None),
	}
    }
}

pub Term: ast::Command = {
    <t:Term> <s:Seperator> <a:AndOr> => {
	match s {
	      None => t,
	      Some(ast::SeperatorOp::Amp) => ast::Command::AsyncList(Box::new(t), Some(Box::new(a))),
	      Some(ast::SeperatorOp::Semi) => ast::Command::SeqList(Box::new(t), Some(Box::new(a))),
	}
    },
    <a:AndOr> => a,
}

// IF CLAUSE

pub IfClause: ast::Command = {
    IF <cond:CompoundList> THEN <body:CompoundList> <mut elifs:ElifBody*> <else_part:ElseBody?> FI => {

	let mut conds = vec![
	    ast::Condition {
		cond: Box::new(cond),
		body: Box::new(body),
	    }
	];
	conds.append(&mut elifs);
	// TODO prob can be done nicer
	let else_part = match else_part {
	    Some(else_part) => Some(Box::new(else_part)),
	    None => None,
	};
	ast::Command::If {
	    conds,
	    else_part,
	}
    }
}

pub ElifBody: ast::Condition = ELIF <cond:CompoundList> THEN <body:CompoundList> => ast::Condition { cond: Box::new(cond), body: Box::new(body) };
pub ElseBody: ast::Command = ELSE <body:CompoundList> => body;

// WHILE/UNTIL CLAUSE

pub WhileClause: ast::Command = {
    WHILE <cond:CompoundList> DO <d:DoGroup> => ast::Command::While { cond: Box::new(cond), body: Box::new(d) },
}

pub UntilClause: ast::Command = {
    UNTIL <cond:CompoundList> <d:DoGroup> => ast::Command::Until { cond: Box::new(cond), body: Box::new(d) },
}

pub DoGroup: ast::Command = DO <body:CompoundList> DONE => body;

pub Redirect: ast::Redirect = {
    <n: IONumber?> "<"  <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::Read },
    <n: IONumber?> ">"  <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::Write },
    <n: IONumber?> "<<" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadAppend },
    <n: IONumber?> ">>" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::WriteAppend },
    <n: IONumber?> "<&" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadDup },
    <n: IONumber?> ">&" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::WriteDup },
    <n: IONumber?> "<>" <file: Filename> => ast::Redirect { n, file, mode: ast::RedirectMode::ReadWrite },
}

pub IONumber: ast::IONumber = r"[0-9]+" => ast::IONumber(usize::from_str(<>).unwrap());
pub CommandWord: ast::Word = r"[\-a-zA-Z][\-a-zA-Z0-9]*" => ast::Word(<>.into());
pub Filename: ast::Filename = r"[\-a-zA-Z][\-a-zA-Z0-9]*" => ast::Filename(<>.into());

pub Assign: ast::Assign = <var:CommandWord> "=" <val:CommandWord> => ast::Assign { var, val };

pub AND_IF: () = "&&" => ();
pub OR_IF: () = "||" => ();
pub IF: () = "if" => ();
pub THEN: () = "then" => ();
pub ELSE: () = "else" => ();
pub ELIF: () = "elif" => ();
pub FI: () = "fi" => ();
pub DO: () = "do" => ();
pub DONE: () = "done" => ();

pub CASE: () = "case" => ();
pub ESAC: () = "esac" => ();
pub WHILE: () = "while" => ();
pub UNTIL: () = "until" => ();
pub FOR: () = "for" => ();

pub Linebreak: () = NewlineList? => ();
pub NewlineList: () = "\n"+ => ();
pub Seperator: Option<ast::SeperatorOp> = {
    <s:SeperatorOp> Linebreak => Some(s),
    NewlineList => None,
}
pub SeperatorOp: ast::SeperatorOp = {
    "&" => ast::SeperatorOp::Amp,
    ";" => ast::SeperatorOp::Semi,
}