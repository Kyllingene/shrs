use std::{io::Write, time::Duration};

use crossterm::{
    event::{poll, read, Event, KeyCode, KeyEvent, KeyModifiers},
    terminal::{disable_raw_mode, enable_raw_mode},
};

use crate::{
    completion::{Completer, Completion, CompletionCtx, DefaultCompleter},
    cursor::{Cursor, DefaultCursor},
    cursor_buffer::{CursorBuffer, Location},
    history::{DefaultHistory, History},
    menu::{DefaultMenu, Menu},
    painter::Painter,
    prompt::Prompt,
    vi::ViAction,
};

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum LineMode {
    /// Vi insert mode
    Insert,
    /// Vi normal mode
    Normal,
}

#[derive(Builder)]
#[builder(pattern = "owned")]
#[builder(setter(prefix = "with"))]
pub struct Line {
    #[builder(default = "Box::new(DefaultMenu::new())")]
    #[builder(setter(custom))]
    menu: Box<dyn Menu<MenuItem = String>>,

    #[builder(default = "Box::new(DefaultCompleter::new(vec![]))")]
    #[builder(setter(custom))]
    completer: Box<dyn Completer>,

    #[builder(default = "Box::new(DefaultHistory::new())")]
    #[builder(setter(custom))]
    history: Box<dyn History<HistoryItem = String>>,

    #[builder(default = "Box::new(DefaultCursor::default())")]
    #[builder(setter(custom))]
    cursor: Box<dyn Cursor>,

    // ignored fields
    #[builder(default = "Painter::new()")]
    #[builder(setter(skip))]
    painter: Painter,
}

impl Default for Line {
    fn default() -> Self {
        LineBuilder::default().build().unwrap()
    }
}

pub struct LineCtx {
    cb: CursorBuffer,
    // TODO this is temp, find better way to store prefix of current word
    current_word: String,
    // TODO dumping history index here for now
    history_ind: i32,
    mode: LineMode,
}

impl Default for LineCtx {
    fn default() -> Self {
        LineCtx {
            cb: CursorBuffer::new(),
            current_word: String::new(),
            history_ind: -1,
            mode: LineMode::Insert,
        }
    }
}

// TODO none of the builder stuff is being autogenerated rn :()
impl LineBuilder {
    pub fn with_menu(mut self, menu: impl Menu<MenuItem = String> + 'static) -> Self {
        self.menu = Some(Box::new(menu));
        self
    }
    pub fn with_completer(mut self, completer: impl Completer + 'static) -> Self {
        self.completer = Some(Box::new(completer));
        self
    }
    pub fn with_history(mut self, history: impl History<HistoryItem = String> + 'static) -> Self {
        self.history = Some(Box::new(history));
        self
    }
    pub fn with_cursor(mut self, cursor: impl Cursor + 'static) -> Self {
        self.cursor = Some(Box::new(cursor));
        self
    }
}

impl Line {
    pub fn read_line<T: Prompt + ?Sized>(&mut self, prompt: impl AsRef<T>) -> String {
        let mut ctx = LineCtx::default();
        self.read_events(&mut ctx, prompt).unwrap()
    }

    fn read_events<T: Prompt + ?Sized>(
        &mut self,
        ctx: &mut LineCtx,
        prompt: impl AsRef<T>,
    ) -> anyhow::Result<String> {
        // ensure we are always cleaning up whenever we leave this scope
        struct CleanUp;
        impl Drop for CleanUp {
            fn drop(&mut self) {
                disable_raw_mode();
            }
        }
        let _cleanup = CleanUp;

        enable_raw_mode()?;

        self.painter.init().unwrap();

        self.painter
            .paint(&prompt, &self.menu, "", ctx.cb.cursor(), &self.cursor)?;

        loop {
            if poll(Duration::from_millis(1000))? {
                let event = read()?;

                // handle menu events
                if self.menu.is_active() {
                    self.handle_menu_keys(ctx, event)?;
                } else {
                    // TODO bit hacky bubbling up control flow from funtion
                    match ctx.mode {
                        LineMode::Insert => {
                            let should_break = self.handle_insert_keys(ctx, event)?;
                            if should_break {
                                break;
                            }
                        },
                        LineMode::Normal => self.handle_normal_keys(ctx, event)?,
                    }
                }

                let res = ctx.cb.slice(..).as_str().unwrap();

                self.painter
                    .paint(&prompt, &self.menu, &res, ctx.cb.cursor(), &self.cursor)?;
            }
        }

        let res = ctx.cb.slice(..).as_str().unwrap().to_string();
        self.history.add(res.clone());
        Ok(res)
    }

    fn handle_menu_keys(&mut self, ctx: &mut LineCtx, event: Event) -> anyhow::Result<()> {
        match event {
            Event::Key(KeyEvent {
                code: KeyCode::Enter,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                let accepted = self.menu.accept().cloned();
                if let Some(accepted) = accepted {
                    self.accept_completion(ctx, &accepted)?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Esc,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.menu.disactivate();
            },
            Event::Key(KeyEvent {
                code: KeyCode::Tab,
                modifiers: KeyModifiers::SHIFT,
                ..
            })
            | Event::Key(KeyEvent {
                code: KeyCode::Up,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.menu.previous();
            },
            Event::Key(KeyEvent {
                code: KeyCode::Tab,
                modifiers: KeyModifiers::NONE,
                ..
            })
            | Event::Key(KeyEvent {
                code: KeyCode::Down,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.menu.next();
            },
            _ => {},
        };
        Ok(())
    }

    fn handle_insert_keys(&mut self, ctx: &mut LineCtx, event: Event) -> anyhow::Result<bool> {
        match event {
            Event::Key(KeyEvent {
                code: KeyCode::Enter,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.painter.newline()?;
                return Ok(true);
            },
            Event::Key(KeyEvent {
                code: KeyCode::Tab,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                // TODO IFS
                let args = ctx.cb.slice(..ctx.cb.cursor()).as_str().unwrap().split(' ');
                ctx.current_word = args.clone().last().unwrap_or("").to_string();

                let comp_ctx = CompletionCtx {
                    arg_num: args.count(),
                };
                let completions = self.completer.complete(&ctx.current_word, comp_ctx);
                let owned = completions
                    .iter()
                    .map(|x| x.to_string())
                    .take(10) // TODO make this config
                    .collect::<Vec<_>>();

                // if completions only has one entry, automatically select it
                if owned.len() == 1 {
                    self.accept_completion(ctx, owned.get(0).unwrap())?;
                } else {
                    self.menu.set_items(owned);
                    self.menu.activate();
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Left,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                if ctx.cb.cursor() > 0 {
                    ctx.cb.move_cursor(Location::Before())?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Right,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                if ctx.cb.cursor() < ctx.cb.len() {
                    ctx.cb.move_cursor(Location::After())?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Backspace,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                if ctx.cb.len() > 0 && ctx.cb.cursor() != 0 {
                    ctx.cb.cursor_delete(Location::Before(), 1)?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Down,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.history_down(ctx)?;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Up,
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.history_up(ctx)?;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Esc, ..
            }) => {
                ctx.mode = LineMode::Normal;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char(c),
                ..
            }) => {
                ctx.cb.cursor_insert(Location::Cursor(), &c.to_string())?;
            },
            _ => {},
        };
        Ok(false)
    }

    fn handle_normal_keys(&mut self, ctx: &mut LineCtx, event: Event) -> anyhow::Result<()> {
        // TODO write better system to support key combinations
        match event {
            Event::Key(KeyEvent {
                code: KeyCode::Char('i'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                ctx.mode = LineMode::Insert;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('h'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                // TODO having to do these bounds checks are not nice, should implement some sort
                // of cb.move_cursor_clamp
                if ctx.cb.cursor() > 0 {
                    ViAction::MoveLeft.execute(&mut ctx.cb)?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('l'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                if ctx.cb.cursor() < ctx.cb.len() {
                    ViAction::MoveRight.execute(&mut ctx.cb)?;
                }
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('j'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.history_down(ctx)?;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('k'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                self.history_up(ctx)?;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('^'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                ViAction::MoveStart.execute(&mut ctx.cb)?;
            },
            Event::Key(KeyEvent {
                code: KeyCode::Char('$'),
                modifiers: KeyModifiers::NONE,
                ..
            }) => {
                ViAction::MoveEnd.execute(&mut ctx.cb)?;
            },
            _ => {},
        }
        Ok(())
    }

    // replace word at cursor with accepted word (used in automcompletion)
    fn accept_completion(&mut self, ctx: &mut LineCtx, accepted: &str) -> anyhow::Result<()> {
        // first remove current word
        // TODO could implement a delete_before
        ctx.cb
            .move_cursor(Location::Rel(-1 * ctx.current_word.len() as isize))?;
        ctx.cb
            .cursor_delete(Location::Cursor(), ctx.current_word.len())?;

        // then replace with the completion word
        ctx.cb.cursor_insert(Location::Cursor(), accepted)?;

        Ok(())
    }

    fn history_up(&mut self, ctx: &mut LineCtx) -> anyhow::Result<()> {
        // TODO make this logic nicer
        ctx.history_ind = (ctx.history_ind + 1).min(self.history.len().saturating_sub(1) as i32);

        if let Some(history_item) = self.history.get(ctx.history_ind as usize) {
            ctx.cb.clear();
            ctx.cb.cursor_insert(Location::Cursor(), history_item)?;
        }
        Ok(())
    }

    fn history_down(&mut self, ctx: &mut LineCtx) -> anyhow::Result<()> {
        ctx.history_ind = (ctx.history_ind - 1).max(0);

        if let Some(history_item) = self.history.get(ctx.history_ind as usize) {
            ctx.cb.clear();
            ctx.cb.cursor_insert(Location::Cursor(), history_item)?;
        }

        Ok(())
    }
}
